{"version":3,"sources":["webpack://PasswordQualityCalculator/webpack/universalModuleDefinition","webpack://PasswordQualityCalculator/webpack/bootstrap","webpack://PasswordQualityCalculator/../lib/PopularPasswords.js","webpack://PasswordQualityCalculator/../lib/PasswordQualityCalculator.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","m_dicts","getMaxLength","iMaxLen","_i","_Object$keys","keys","length","iLen","parseInt","ContainsLength","nLength","IsPopularPassword","password","Error","includes","GetDictSize","load","passwordList","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","pw","push","err","reset","_readOnlyError","PatternID","LowerAlpha","UpperAlpha","Digit","Special","High","Other","Dictionary","Repetition","Number","DiffSeq","All","PrintableAsciiSpecial","UpperCase","LowerCase","Digits","HighAnsiChars","ch","sbHighAnsi","String","fromCharCode","apply","Assert","ok","msg","m_lCharTypes","QeCharType","chTypeID","strAlphabet","bIsConsecutive","nChars","_classCallCheck","RangeError","TypeID","Alphabet","CharCount","m_chFirst","charCodeAt","m_chLast","CharSize","Math","log2","indexOf","EntropyEncoder","uBaseWeight","uCharWeight","uOccExclThreshold","m_strAlph","m_uBaseWeight","m_uCharWeight","m_uOccExclThreshold","m_dHisto","uOcc","uTotalWeight","_Object$values","values","u","dSize","dTotalWeight","_i2","_Object$values2","uWeight","MultiEntropyEncoder","m_dEncs","ec","_i3","_Object$values3","Reset","chData","Write","_i4","_Object$values4","GetOutputSize","QePatternInstance","iPosition","chPatternID","dblCost","ctSingle","Position","Length","Cost","SingleCharType","QePathState","lPath","Path","GetCharType","nTypes","Contains","ComputePathCost","vPassword","ecPattern","mcData","dblPatternCost","dblDataCost","pi","tChar","PartsEqual","v","x1","x2","ErasePart","chErased","j","AddNumberPattern","vPatterns","sb","strNumber","nZeros","strNonZero","substring","parseFloat","FindPopularPasswords","vLower","toLowerCase","vLeet","str","newstr","DecodeLeetChar","charAt","DecodeLeet","nSubLen","min","PopularPasswords","vSub","EvalAddPopularPasswordPattern","StringClear","pos","count","erased","chLeet","sub","dblCostPerMod","uDictSize","v1","iOffset1","v2","iOffset2","nDist","HammingDist","k","PasswordQualityCalculator","strSpecial","nSp","nHi","EnsureInitialized","string","array","stringToArray","bFoundRep","FindRepetitions","FindNumbers","Infinity","dCur","FindDiffSeqs","uw","sqrt","AddEncoder","dblMinCost","tStart","Date","now","sRec","pop","lSubs","lNewPath","_toConsumableArray","sNew","ceil"],"mappings":"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","file":"PasswordQualityCalculator.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PasswordQualityCalculator\"] = factory();\n\telse\n\t\troot[\"PasswordQualityCalculator\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const m_dicts = {};\n\nexport function getMaxLength() {\n  let iMaxLen = 0;\n  for (let iLen of Object.keys(m_dicts)) {\n    if (parseInt(iLen) > iMaxLen) iMaxLen = parseInt(iLen);\n  }\n  return iMaxLen;\n}\n\nexport function ContainsLength(nLength) {\n  return nLength in m_dicts;\n}\n\nexport function IsPopularPassword(password) {\n  if (password == null) throw new Error();\n  if (password.length == 0) { return false; }\n\n  if (!(password.length in m_dicts)) {\n    return false;\n  }\n\n  return m_dicts[password.length].includes(password);\n}\n\nexport function GetDictSize(length) {\n\n  if (!(length in m_dicts)) {\n    return 0;\n  }\n\n  return m_dicts[length].length;\n}\n\nexport function load(passwordList) {\n  for (let pw of passwordList) {\n    if (pw.length in m_dicts) {\n      m_dicts[pw.length].push(pw);\n    } else {\n      m_dicts[pw.length] = [pw];\n    }\n  }\n}\n\nexport function reset() {\n  m_dicts = {}\n}","import * as PopularPasswords from './PopularPasswords.js';\n\nconst PatternID = {\n  LowerAlpha: 'L',\n  UpperAlpha: 'U',\n  Digit: 'D',\n  Special: 'S',\n  High: 'H',\n  Other: 'X',\n\n  Dictionary: 'W',\n  Repetition: 'R',\n  Number: 'N',\n  DiffSeq: 'C',\n\n  All: \"LUDSHXWRNC\"\n};\nconst PrintableAsciiSpecial = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nconst UpperCase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst LowerCase = \"abcdefghijklmnopqrstuvwxyz\";\nconst Digits = \"0123456789\";\nconst HighAnsiChars = (() => {\n  let sbHighAnsi = [], ch;\n  for(ch = 0x00A1; ch <= 0x00AC; ++ch)\n    sbHighAnsi.push(ch);\n  for(ch = 0x00AE; ch < 0x00FF; ++ch)\n    sbHighAnsi.push(ch);\n  sbHighAnsi.push(0x00FF);\n  return String.fromCharCode.apply(null, sbHighAnsi);\n})();\n\nfunction Assert(ok, msg) {\n  if (!ok) {\n    throw new Error(msg);\n  }\n}\n\n\nclass QeCharType {\n  constructor(chTypeID, strAlphabet, bIsConsecutive) {\n    let nChars;\n    if (typeof strAlphabet === 'string') {\n      if(strAlphabet.length === 0) throw new Error();\n    } else if (typeof strAlphabet === 'number') {\n      if(nChars <= 0) throw new RangeError();\n      nChars = strAlphabet;\n      strAlphabet = null;\n      bIsConsecutive = false;\n    } else {\n      throw new Error();\n    }\n\n    this.TypeID = chTypeID;\n    this.Alphabet = strAlphabet;\n    this.CharCount = nChars || this.Alphabet.length;\n    this.m_chFirst = (bIsConsecutive ? this.Alphabet.charCodeAt(0) : null);\n    this.m_chLast = (bIsConsecutive ? this.Alphabet.charCodeAt(this.CharCount - 1) : null);\n\n    this.CharSize = Math.log2(this.CharCount);\n    nChars || Assert((this.m_chLast - this.m_chFirst) == (this.CharCount - 1) || !bIsConsecutive);\n  }\n\n  Contains(ch)\n  {\n    if(this.m_chLast !== null)\n      return ((ch >= this.m_chFirst) && (ch <= this.m_chLast));\n\n    if (this.Alphabet.length === 0) throw new Error('Don\\'t call for catch-none set')\n    return (this.Alphabet.indexOf(String.fromCharCode(ch)) >= 0);\n  }\n}\n\nclass EntropyEncoder {\n  constructor(strAlphabet, uBaseWeight,\n    uCharWeight, uOccExclThreshold)\n  {\n    if(strAlphabet === null || strAlphabet.length === 0) throw new Error();\n\n    this.m_strAlph = strAlphabet;\n    this.m_uBaseWeight = uBaseWeight;\n    this.m_uCharWeight = uCharWeight;\n    this.m_uOccExclThreshold = uOccExclThreshold;\n\n    this.m_dHisto = {}\n  }\n\n  Reset()\n  {\n    this.m_dHisto = {};\n  }\n\n\tWrite(ch)\n  {\n    Assert(this.m_strAlph.indexOf(ch) >= 0);\n\n    let uOcc = this.m_dHisto[ch] || 0;\n    Assert(ch in this.m_dHisto || uOcc === 0);\n    this.m_dHisto[ch] = uOcc + 1;\n  }\n\n  GetOutputSize()\n  {\n    let uTotalWeight = this.m_uBaseWeight * this.m_strAlph.length;\n    for (let u of Object.values(this.m_dHisto))\n    {\n      Assert(u >= 1);\n      if(u > this.m_uOccExclThreshold)\n        uTotalWeight += (u - this.m_uOccExclThreshold) * this.m_uCharWeight;\n    }\n\n    let dSize = 0.0, dTotalWeight = uTotalWeight;\n    for (let u of Object.values(this.m_dHisto))\n    {\n      let uWeight = this.m_uBaseWeight;\n      if(u > this.m_uOccExclThreshold)\n        uWeight += (u - this.m_uOccExclThreshold) * this.m_uCharWeight;\n\n      dSize -= u * Math.log2(uWeight / dTotalWeight);\n    }\n\n    return dSize;\n  }\n}\n\nclass MultiEntropyEncoder {\n  constructor() {\n    this.m_dEncs = {};\n  }\n\n  AddEncoder(chTypeID, ec)\n  {\n    Assert(ec);\n\n    Assert(!(chTypeID in this.m_dEncs));\n    this.m_dEncs[chTypeID] = ec;\n  }\n\n  Reset()\n  {\n    for(let ec of Object.values(this.m_dEncs)) {\n      ec.Reset();\n    }\n  }\n\n  Write(chTypeID, chData)\n  {\n    let ec = this.m_dEncs[chTypeID];\n    if(!ec)\n      return false;\n\n    ec.Write(chData);\n    return true;\n  }\n\n  GetOutputSize()\n  {\n    let d = 0.0;\n\n    for (let ec of Object.values(this.m_dEncs))\n    {\n      d += ec.GetOutputSize();\n    }\n\n    return d;\n  }\n}\n\nclass QePatternInstance\n{\n  constructor(iPosition, nLength, chPatternID, dblCost) {\n    let ctSingle;\n    if (typeof dblCost === 'number') {\n      this.Position = iPosition;\n      this.Length = nLength;\n      this.PatternID = chPatternID;\n      this.Cost = dblCost;\n      this.SingleCharType = null;\n    } else {\n      ctSingle = chPatternID;\n\n      this.Position = iPosition;\n      this.Length = nLength;\n      this.PatternID = ctSingle.TypeID;\n      this.Cost = ctSingle.CharSize;\n      this.SingleCharType = ctSingle;\n    }\n  }\n}\n\nclass QePathState {\n  constructor(iPosition, lPath) {\n    this.Position = iPosition;\n    this.Path = lPath;\n  }\n}\n\nlet m_objSyncInit;\nlet m_lCharTypes;\n\nfunction EnsureInitialized() {\n  if(m_lCharTypes == null)\n  {\n    let strSpecial = PrintableAsciiSpecial;\n    strSpecial = strSpecial + \" \";\n\n    let nSp = strSpecial.length;\n    let nHi = HighAnsiChars.length;\n\n    m_lCharTypes = [];\n\n    m_lCharTypes.push(new QeCharType(PatternID.LowerAlpha,\n      LowerCase, true));\n    m_lCharTypes.push(new QeCharType(PatternID.UpperAlpha,\n      UpperCase, true));\n    m_lCharTypes.push(new QeCharType(PatternID.Digit,\n      Digits, true));\n    m_lCharTypes.push(new QeCharType(PatternID.Special,\n      strSpecial, false));\n    m_lCharTypes.push(new QeCharType(PatternID.High,\n      HighAnsiChars, false));\n    m_lCharTypes.push(new QeCharType(PatternID.Other,\n      0x10000 - (2 * 26) - 10 - nSp - nHi));\n  }\n}\n\nfunction GetCharType(ch) {\n  let nTypes = m_lCharTypes.length;\n  Assert((nTypes > 0) && (m_lCharTypes[nTypes - 1].CharCount > 256));\n\n  for(let i = 0; i < (nTypes - 1); ++i)\n  {\n    if(m_lCharTypes[i].Contains(ch))\n      return m_lCharTypes[i];\n  }\n\n  return m_lCharTypes[nTypes - 1];\n}\n\nfunction ComputePathCost(l, vPassword, ecPattern, mcData)\n{\n  ecPattern.Reset();\n  for(let i = 0; i < l.length; ++i)\n    ecPattern.Write(l[i].PatternID);\n  let dblPatternCost = ecPattern.GetOutputSize();\n\n  mcData.Reset();\n  let dblDataCost = 0.0;\n  for(let pi of l)\n  {\n    let tChar = pi.SingleCharType;\n    if(tChar != null)\n    {\n      let ch = vPassword[pi.Position];\n      if(!mcData.Write(tChar.TypeID, ch))\n        dblDataCost += pi.Cost;\n    }\n    else dblDataCost += pi.Cost;\n  }\n  dblDataCost += mcData.GetOutputSize();\n\n  return (dblPatternCost + dblDataCost);\n}\n\nfunction FindRepetitions(vPassword, vPatterns)\n{\n  let v = stringToArray(vPassword);\n  let n = vPassword.length;\n\n  let chErased = 0xffff;\n  for(let m = (n / 2); m >= 3; --m)\n  {\n    for(let x1 = 0; x1 <= (n - (2 * m)); ++x1)\n    {\n      let bFoundRep = false;\n\n      for(let x2 = (x1 + m); x2 <= (n - m); ++x2)\n      {\n        if(PartsEqual(v, x1, x2, m))\n        {\n          let dblCost = Math.log2(x1 + 1) + Math.log2(m);\n          vPatterns[x2].push(new QePatternInstance(x2, m,\n            PatternID.Repetition, dblCost));\n\n          chErased = ErasePart(v, x2, m, chErased);\n\n          bFoundRep = true;\n        }\n      }\n\n      if (bFoundRep) chErased = ErasePart(v, x1, m, chErased);\n    }\n  }\n}\n\nfunction PartsEqual(v, x1, x2, nLength)\n{\n  for(let i = 0; i < nLength; ++i)\n  {\n    if(v[x1 + i] != v[x2 + i]) return false;\n  }\n\n  return true;\n}\n\nfunction ErasePart(v, i, n, chErased)\n{\n  for(let j = 0; j < n; ++j) {\n    v[i + j] = chErased;\n    --chErased;\n  }\n\n  return chErased;\n}\n\nfunction stringToArray(string) {\n  let array = [];\n  for (let i = 0; i < string.length; i++) {\n    array.push(string.charCodeAt(i));\n  }\n  return array;\n}\n\nfunction FindNumbers(vPassword, vPatterns)\n{\n  let n = vPassword.length;\n  let sb = [];\n\n  for(let i = 0; i < n; ++i)\n  {\n    let ch = vPassword.charCodeAt(i);\n    if((ch >= 0x30) && (ch <= 0x39)) sb.push(ch);\n    else\n    {\n      AddNumberPattern(vPatterns, sb, i - sb.length);\n      sb = [];\n    }\n  }\n  AddNumberPattern(vPatterns, sb, n - sb.length);\n}\n\nfunction AddNumberPattern(vPatterns, sb, i)\n{\n  if(sb.length <= 2) return;\n  let strNumber = String.fromCharCode.apply(null,sb);\n\n  let nZeros = 0;\n  for(let j = 0; j < strNumber.length; ++j)\n  {\n    if(strNumber.charCodeAt(j) != 0x30) break;\n    ++nZeros;\n  }\n\n  let dblCost = Math.log2(nZeros + 1);\n  if(nZeros < strNumber.length)\n  {\n    let strNonZero = strNumber.substring(nZeros);\n\n    dblCost += Math.log2(parseFloat(strNonZero));\n  }\n\n  vPatterns[i].push(new QePatternInstance(i, strNumber.length,\n    PatternID.Number, dblCost));\n}\n\nfunction FindDiffSeqs(vPassword, vPatterns) {\n  let n = vPassword.length;\n  let d = Infinity, p = 0;\n\n  for(let i = 1; i <= n; ++i)\n  {\n    let dCur = ((i == n) ? Infinity :\n      (vPassword.charCodeAt(i) - vPassword.charCodeAt(i - 1)));\n    if(dCur != d)\n    {\n      if((i - p) >= 3) // At least 3 chars involved\n      {\n        let ct = GetCharType(vPassword.charCodeAt(p));\n        let dblCost = ct.CharSize + Math.log2(i - p - 1);\n\n        vPatterns[p].push(new QePatternInstance(p,\n          i - p, PatternID.DiffSeq, dblCost));\n      }\n\n      d = dCur;\n      p = i - 1;\n    }\n  }\n}\n\nfunction DecodeLeet(str) {\n  let newstr = '';\n  for (let i = 0; i < str.length; i++) {\n    let char = str.charAt(i);\n    let decoded = DecodeLeetChar(char);\n    newstr += decoded;\n  }\n  return newstr;\n}\n\nfunction FindPopularPasswords(vPassword, vPatterns) {\n  let n = vPassword.length;\n\n  let vLower = vPassword.toLowerCase();\n  let vLeet = DecodeLeet(vLower);\n\n  for(let nSubLen = Math.min(n, PopularPasswords.getMaxLength()); nSubLen >= 3; --nSubLen) {\n    if (!PopularPasswords.ContainsLength(nSubLen)) continue;\n\n    for(let i = 0; i <= (n - nSubLen); ++i)\n\t\t{\n      let vSub = vLower.substring(i, i + nSubLen);\n\n      if (!vSub || vSub.indexOf('\\u0000') !== -1) {\n        continue;\n      }\n\n      if(!EvalAddPopularPasswordPattern(vPatterns, vPassword,\n        i, vSub, 0.0))\n      {\n        let vLeetSub = vLeet.substring(i, nSubLen);\n        if(EvalAddPopularPasswordPattern(vPatterns, vPassword,\n          i, vLeetSub, 1.5))\n        {\n          vLower = StringClear(vLower, i, nSubLen); // Not vLeet\n        }\n      }\n      else\n      {\n        vLower = StringClear(vLower, i, nSubLen); // Not vLeet\n      }\n    }\n  }\n}\n\nfunction StringClear(str, pos, count) {\n  let erased = ''\n  for (let i = 0;i < count;i++) {\n    erased += '\\u0000'\n  }\n  return str.substring(0, pos) + erased + str.substring(pos + count);\n}\n\nfunction DecodeLeetChar(chLeet) {\n  if((chLeet.charCodeAt(0) >= 0x00C0) && (chLeet.charCodeAt(0) <= 0x00C6)) return 'a';\n  if((chLeet.charCodeAt(0) >= 0x00C8) && (chLeet.charCodeAt(0) <= 0x00CB)) return 'e';\n  if((chLeet.charCodeAt(0) >= 0x00CC) && (chLeet.charCodeAt(0) <= 0x00CF)) return 'i';\n  if((chLeet.charCodeAt(0) >= 0x00D2) && (chLeet.charCodeAt(0) <= 0x00D6)) return 'o';\n  if((chLeet.charCodeAt(0) >= 0x00D9) && (chLeet.charCodeAt(0) <= 0x00DC)) return 'u';\n  if((chLeet.charCodeAt(0) >= 0x00E0) && (chLeet.charCodeAt(0) <= 0x00E6)) return 'a';\n  if((chLeet.charCodeAt(0) >= 0x00E8) && (chLeet.charCodeAt(0) <= 0x00EB)) return 'e';\n  if((chLeet.charCodeAt(0) >= 0x00EC) && (chLeet.charCodeAt(0) <= 0x00EF)) return 'i';\n  if((chLeet.charCodeAt(0) >= 0x00F2) && (chLeet.charCodeAt(0) <= 0x00F6)) return 'o';\n  if((chLeet.charCodeAt(0) >= 0x00F9) && (chLeet.charCodeAt(0) <= 0x00FC)) return 'u';\n\n  switch(chLeet)\n  {\n    case '4':\n    case '@':\n    case '?':\n    case '^':\n    case '\\u00AA': return 'a';\n    case '8':\n    case '\\u00DF': return 'b';\n    case '(':\n    case '{':\n    case '[':\n    case '<':\n    case '\\u00A2':\n    case '\\u00A9':\n    case '\\u00C7':\n    case '\\u00E7': return 'c';\n    case '\\u00D0':\n    case '\\u00F0': return 'd';\n    case '3':\n    case '\\u20AC':\n    case '&':\n    case '\\u00A3': return 'e';\n    case '6':\n    case '9': return 'g';\n    case '#': return 'h';\n    case '1':\n    case '!':\n    case '|':\n    case '\\u00A1':\n    case '\\u00A6': return 'i';\n    case '\\u00D1':\n    case '\\u00F1': return 'n';\n    case '0':\n    case '*':\n    case '\\u00A4': // Currency\n    case '\\u00B0': // Degree\n    case '\\u00D8':\n    case '\\u00F8': return 'o';\n    case '\\u00AE': return 'r';\n    case '$':\n    case '5':\n    case '\\u00A7': return 's';\n    case '+':\n    case '7': return 't';\n    case '\\u00B5': return 'u';\n    case '%':\n    case '\\u00D7': return 'x';\n    case '\\u00A5':\n    case '\\u00DD':\n    case '\\u00FD':\n    case '\\u00FF': return 'y';\n    case '2': return 'z';\n    default: return chLeet;\n  }\n}\n\nfunction EvalAddPopularPasswordPattern(vPatterns, vPassword, i, sub, dblCostPerMod)\n{\n  let IsPopularPassword = PopularPasswords.IsPopularPassword(sub);\n  let uDictSize = PopularPasswords.GetDictSize(sub.length);\n  if(!IsPopularPassword)\n    return false;\n\n  let n = sub.length;\n  let d = HammingDist(sub, 0, vPassword, i, n);\n\n  let dblCost = Math.log2(uDictSize);\n\n  // dblCost += Math.log2(n binom d)\n  let k = Math.min(d, n - d);\n  for(let j = n; j > (n - k); --j)\n    dblCost += Math.log2(j);\n  for(let j = k; j >= 2; --j)\n    dblCost -= Math.log2(j);\n\n  dblCost += dblCostPerMod * d;\n\n  vPatterns[i].push(new QePatternInstance(i, n, PatternID.Dictionary,\n    dblCost));\n  return true;\n}\n\nfunction HammingDist(v1, iOffset1, v2, iOffset2, nLength)\n{\n  let nDist = 0;\n  for(let i = 0; i < nLength; ++i)\n  {\n    if(v1.charCodeAt(iOffset1 + i) !== v2.charCodeAt(iOffset2 + i)) ++nDist;\n  }\n\n  return nDist;\n}\n\nexport default function PasswordQualityCalculator(vPassword)\n{\n  if (typeof vPassword !== 'string' || vPassword.length === 0) return 0;\n\n  EnsureInitialized();\n\n  let n = vPassword.length;\n  let vPatterns = [];\n\n  for (let i = 0; i < n; i++) {\n    vPatterns[i] = [\n      new QePatternInstance(i, 1, GetCharType(vPassword.charCodeAt(i)))\n    ];\n  }\n\n  FindRepetitions(vPassword, vPatterns);\n  FindNumbers(vPassword, vPatterns);\n  FindDiffSeqs(vPassword, vPatterns);\n  FindPopularPasswords(vPassword, vPatterns);\n\n  // Encoders must not be static, because the entropy estimation\n  // may run concurrently in multiple threads and the encoders are\n  // not read-only\n  let ecPattern = new EntropyEncoder(PatternID.All, 0, 1, 0);\n  let mcData = new MultiEntropyEncoder();\n\n  for(let i = 0; i < (m_lCharTypes.length - 1); ++i)\n  {\n    // Let m be the alphabet size. In order to ensure that two same\n    // characters cost at least as much as a single character, for\n    // the probability p and weight w of the character it must hold:\n    //     -log(1/m) >= -2*log(p)\n    // <=> log(1/m) <= log(p^2) <=> 1/m <= p^2 <=> p >= sqrt(1/m);\n    //     sqrt(1/m) = (1+w)/(m+w)\n    // <=> m+w = (1+w)*sqrt(m) <=> m+w = sqrt(m) + w*sqrt(m)\n    // <=> w*(1-sqrt(m)) = sqrt(m) - m <=> w = (sqrt(m)-m)/(1-sqrt(m))\n    // <=> w = (sqrt(m)-m)*(1+sqrt(m))/(1-m)\n    // <=> w = (sqrt(m)-m+m-m*sqrt(m))/(1-m) <=> w = sqrt(m)\n    let uw = Math.sqrt(m_lCharTypes[i].CharCount) | 0;\n\n    mcData.AddEncoder(m_lCharTypes[i].TypeID, new EntropyEncoder(\n      m_lCharTypes[i].Alphabet, 1, uw, 1));\n  }\n\n  let dblMinCost = Infinity;\n  let tStart = Date.now();\n  \n  let sRec = [];\n  sRec.push(new QePathState(0, []));\n\n\n  while(sRec.length > 0)\n  {\n    let tDiff = Date.now() - tStart;\n    if(tDiff > 500) break;\n\n    let s = sRec.pop();\n\n    if(s.Position >= n)\n    {\n      Assert(s.Position === n);\n\n      let dblCost = ComputePathCost(s.Path, vPassword,\n        ecPattern, mcData);\n      if(dblCost < dblMinCost) dblMinCost = dblCost;\n    }\n    else\n    {\n      let lSubs = vPatterns[s.Position];\n      for(let i = lSubs.length - 1; i >= 0; --i)\n      {\n        let pi = lSubs[i];\n        Assert(pi.Position == s.Position);\n        Assert(pi.Length >= 1);\n\n        let lNewPath = [];\n        lNewPath.push(...s.Path);\n        lNewPath.push(pi);\n\n        let sNew = new QePathState(s.Position +\n          pi.Length, lNewPath);\n        sRec.push(sNew);\n      }\n    }\n  }\n\n  return Math.ceil(dblMinCost);\n}\n\nPasswordQualityCalculator.PopularPasswords = PopularPasswords;"],"sourceRoot":""}